\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage[margin=2cm]{geometry}
\usepackage{fancyvrb,xcolor}
\usepackage[urlcolor=blue,linkcolor=black,colorlinks=true]{hyperref}
\urlstyle{rm}
\usepackage{wrapfig}
\usepackage{tabularx}

\setlength\parindent{0pt}

\newcommand{\code}[1]{\colorbox{yellow!15}{\ttfamily #1}}
\newcommand{\val}[1]{{\ttfamily \textit{#1}}}
\newcommand{\blue}[1]{{\color{blue} #1}}

\usepackage{listings}
\lstset{backgroundcolor=\color{yellow!15}, basicstyle=\ttfamily, columns=fullflexible, keepspaces=true,escapeinside={<>}{<>}}

\begin{document}

\title{Post-processing SMILEI diagnostics}
\maketitle
\vfill
A python script \textit{Diagnostics.py} is provided to view or extract data from all the diagnostics.
To run this script, you will need \textit{python2.7} with the following packages: numpy, matplotlib, pylab, h5py.
\\*

First, run python and include the script: \code{python -i scripts/Diagnostics.py}\\*
Alternately, include this file into your own script: \code{execfile("scripts/Diagnostics.py")}


\vfill
\setcounter{tocdepth}{1}
\tableofcontents
\vfill
\clearpage

\section{To select the simulation that you want to analyse}

\begin{lstlisting}
Smilei(results_path)
\end{lstlisting}

\begin{itemize}
\item \code{results\_path} = \code{\_string\_}\\*
	Path to the directory where the results of the simulation are stored.\\*
\end{itemize}

You can store this to a variable for later, for instance: \code{S = Smilei("path/to/my/results")}.

\section{To prepare a scalar diagnostic}

\begin{lstlisting}
Smilei(...).Scalar(scalar=None, timesteps=None, units="code", data_log=False)
\end{lstlisting}

\begin{itemize}
\item \code{scalar} = \code{\_string\_} (optional)\\*
	If not given, then a list of available scalars is printed.\\*
	If \code{\_string\_}: name of the scalar.\\*

\item \code{timesteps} =  \code{\_int\_ }          (optional)\\*
	\code{timesteps} = \code{[\_int\_, \_int\_]}   (optional)\\*
	If omitted, all timesteps are used.\\*
	If one number  given, the nearest timestep available is used.\\*
	If two numbers given, all the timesteps in between are used.

\item \code{units} = \code{"nice"}    (optional)\\*
	If \code{"nice"} is chosen, then units are converted into usual units.\\*
	Distances in microns, density in cm$^{-3}$, energy in MeV.

\item \code{data\_log} = \code{True} or (\code{False})       (optional)\\*
	If True, then $\log_{10}$ is applied to the output.
\end{itemize}
\vspace{0.5cm}

\section{To prepare a field diagnostic}

\begin{lstlisting}
Smilei(...).Field(field=None, timesteps=None, slice=None, units="code", data_log=False)
\end{lstlisting}

\begin{itemize}
\item \code{timesteps}, \code{units}, \code{data\_log}: same as before.
\item \code{field} = \code{\_string\_} (optional)\\*
	If not given, then a list of available fields is printed.\\*
	If \code{\_string\_}: name of the field.\\*
	The string can also be an operation between several fields, such as \code{"Jx+Jy"}.
\item \code{slice} = \code{\{ \val{axis} : "all", ... \}}                 (optional)\\*
	\code{slice} = \code{\{ \val{axis} : \_double\_, ... \}}              (optional)\\*
	\code{slice} = \code{\{ \val{axis} : [\_double\_, \_double\_], ... \}}  (optional)\\*
	This parameter is used to reduce the number of dimensions of the array.\\*
	\val{axis} must be \code{"x"}, \code{"y"} or \code{"z"}.\\*
	 The chosen axes will be removed:\\*
	- If the value is \code{"all"}, then an average is performed over all the axis.\\*
	- If the value is \code{\_double\_}, then only the bin closest to the value is kept.\\*
	- If the value is \code{[\_double\_,\_double\_]}, then an average is performed between the two values.\\*
	Example: \code{\{"x":[4,5]\}} will average all the data for x in the range [4,5].
\end{itemize}
\vspace{0.5cm}


\section{To prepare a probe diagnostic}

\begin{lstlisting}
Smilei(...).Probe(probeNumber=None, field=None, timesteps=None, slice=None,
                  units="code", data_log=False)
\end{lstlisting}

\begin{itemize}
\item \code{timesteps}, \code{units}, \code{data\_log}: same as before.
\item \code{probeNumber} = \code{\_int\_} (optional)\\*
	If not given, then a list of available probes is printed.\\*
	If \code{\_int\_}: number of the probe. The first one has number 0.\\*
\item \code{field} = \code{\_string\_} (optional)\\*
	If not given, then a list of available fields is printed.\\*
	If \code{\_string\_}: field name, \code{"Bx"}, \code{"By"}, \code{"Bz"}, \code{"Ex"}, \code{"Ey"}, \code{"Ez"}, \code{"Jx"}, \code{"Jy"}, \code{"Jz"} or \code{"Rho"}.\\*
	The string can also be an operation between several fields, such as \code{"Jx+Jy"}.
\item \code{slice} is very similar to that of \code{Field()}, but it can only accept two axes: \code{"axis1"}, \code{"axis2"}.
	For instance, \code{slice=\{"axis1":"all"\}}. Also, \code{"axis1"} and \code{"axis2"} are not necessarily $x$ or $y$ because the probe mesh may be rotated.
\end{itemize}
\vspace{0.5cm}


\section{To prepare a particle diagnostic}

\begin{lstlisting}
Smilei(...).ParticleDiagnostic(diagNumber=None, timesteps=None, slice=None,
                               units="code", data_log=False)
\end{lstlisting}


\begin{itemize}
\item \code{timesteps}, \code{units}, \code{data\_log}: same as before.
\item \code{diagNumber} = \code{\_int\_} or  \code{\_string\_} (optional)\\*
	If not given, then a list of available particle diagnostics is printed.\\*
	If \code{\_int\_}: number of the particle diagnostic. The first one has number 0.\\*
	If \code{\_string\_}: operation between several particle diagnostics.
	For example, \code{"\#0/\#1"} computes the division by diagnostics 0 and 1.
\item \code{slice} = \code{\{ \val{axis} : "all", ... \}}                 (optional)\\*
	\code{slice} = \code{\{ \val{axis} : \_double\_, ... \}}              (optional)\\*
	\code{slice} = \code{\{ \val{axis} : [\_double\_, \_double\_], ... \}}  (optional)\\*
	This parameter is used to reduce the number of dimensions of the array.\\*
	\val{axis} must be \code{"x"}, \code{"y"}, \code{"z"}, \code{"px"}, \code{"py"}, \code{"pz"}, \code{"p"},
	 \code{"gamma"}, \code{"ekin"}, \code{"vx"}, \code{"vy"}, \code{"vz"}, \code{"v"} or \code{"charge"}.\\*
	 Any axis of the same name will be removed with the following technique:\\*
	- If the value is \code{"all"}, then a \underline{sum} is performed over all the axis.\\*
	- If the value is \code{\_double\_}, then only the bin closest to the value is kept.\\*
	- If the value is \code{[\_double\_,\_double\_]}, then a \underline{sum} is performed between the two values.\\*
	Example: \code{\{"x":[4,5]\}} will sum all the data for x in the range [4,5].
\end{itemize}
\vspace{0.5cm}

\textbf{About Operations:}\\
Sometimes, you have two (or more) diagnostics and you want to combine them with some operation.
For example, imagine that you have one diagnostic with \code{output=px\_density} and another one with \code{output=density}.
You may want to divide the first by the second in order to obtain the average $p_x$.\\
This is directly possible here by using the argument \code{diagNumber}: you simply need to define this argument
as a string containing an operation of your choice, and use a pound sign (\#) to indicate each diagnostic. For example,
the string \code{"\#1 / \#0"} will achieve the division between diagnostics \#1 and \#0.\\*
This feature is very useful as you can make any type of operation, as long as the two diagnostics have the same axes
and the same timesteps.\\


\section{To prepare a test-particle diagnostic}

\begin{lstlisting}
Smilei(...).TestParticles(species=None, select="", axes=[],
                          timesteps=None, units="code"     )
\end{lstlisting}


\begin{itemize}
\item \code{timesteps}, \code{units}: same as before.
\item \code{species} = \code{\_string\_} (optional)\\
	The name of a test-particle species.\\
	If omitted, then a list of available test-particle species is printed.
\item \code{select} = \code{\_string\_} (optional)\\
	Instructions for selecting particles among those available.\\
	The syntax is either \code{select="any(\val{times},\val{condition})"}
	or \code{select="all(\val{times},\val{condition})"}.\\
	\val{times} is a selection of timesteps \code{t}, for instance \code{t>50}.\\
	\val{condition} is a condition on particles properties  (\code{x}, \code{y}, \code{z},
	\code{px}, \code{py}, \code{pz}), for instance \code{px>0}.\\
	The function \code{any()} selects particles satisfying the \val{condition} for at least one of the \val{times}.\\
	The function \code{all()} selects particles satisfying the \val{condition} at all \val{times}.\\
	\textbf{Example:} \code{select="all(t<40, px<0.1)"} selects particles that kept $p_x<0.1$ until timestep 40.\\
	\textbf{Example:} \code{select="any(t>0, px>1.)"} selects particles that reached $p_x>1$ at some point.\\
	It is possible to make logical operations: \code{+} is \emph{OR}; \code{*} is \emph{AND};
	 \code{-} is \emph{NOT}.\\
	\textbf{Example:} \code{select="any((t>30)*(t<60), px>1) + all(t>0, (x>1)*(x<2))"}
\item \code{axes} = \code{[\_string\_, \_string\_, ...]} (optional)
	A list of axes for plotting the trajectories.\\
	Each axis is \code{"x"}, \code{"y"}, \code{"z"}, \code{"px"}, \code{"py"} or \code{"pz"}.\\
	\textbf{Example:} \code{axes = ["x"]} corresponds to $x$ versus time. \\
	\textbf{Example:} \code{axes = ["x","y"]} correspond to 2-D trajectories. \\
	\textbf{Example:} \code{axes = ["x","px"]} correspond to phase-space trajectories.\\ 
\end{itemize}
\vspace{0.5cm}



\section{To obtain the data as an array}
The method \code{getData} returns a list of the data arrays (for each timestep requested).
\begin{lstlisting}
Smilei(...).Scalar(...).getData()
Smilei(...).Field(...).getData()
Smilei(...).Probe(...).getData()
Smilei(...).ParticleDiagnostic(...).getData()
\end{lstlisting}

The method \code{get} returns more things.
\begin{lstlisting}
Smilei(...).Scalar(...).get()
Smilei(...).Field(...).get()
Smilei(...).Probe(...).get()
Smilei(...).ParticleDiagnostic(...).get()
\end{lstlisting}
This method returns the results as a python dictionary:
\begin{lstlisting}
{"data":<>\val{data\_array}<>, "times":<>\val{times\_array}<>, <>\val{axis1}<>:<>\val{axis1\_array}<>, <>\val{axis2}<>:<>\val{axis2\_array}<>, ...}
\end{lstlisting}
where:
\begin{itemize}
\item \val{data\_array} is the result of \code{getData()}.
\item \val{times\_array} is a list of the requested timesteps.
\item \val{axis1}, \val{axis2} (...) are the names of the axes, if any (for example \code{"x"} or \code{"px"}).
\item \val{axis1\_array}, \val{axis2\_array} (...) are the locations of the axes bins, if any.\\*
\end{itemize}

\textbf{Example:}
\begin{lstlisting}
>>> S = Smilei("path/to/my/results")
>>> Diag = S.ParticleDiagnostic(diagNumber=3, slice={"ekin":[1,10]}, timesteps=1000)
>>> result = Diag.get()
\end{lstlisting}
This will take the particle diagnostic \#3 for the timestep nearest to 1000, and sum for all energies between 1 and 10.
The results are stored in the variable \code{result}.\\*
The data can be accessed with \code{result["data"]}.\\*
If one of the axes is \val{x}, you can access the locations of the bins with \code{result["x"]}.\\* \\*

\textbf{Exception:} for test particles, the output is different.


\section{To plot the data}
Use the method \code{plot} to display the data. New arguments are available to modify some plot options.
\begin{lstlisting}
Smilei(...).Scalar            ( ... , figure=1, vmin=None, vmax=None,
                                  xmin=None, xmax=None, ymin=None, ymax=None ).plot()
Smilei(...).Field             ( ... , figure=1, vmin=None, vmax=None,
                                  xmin=None, xmax=None, ymin=None, ymax=None ).plot()
Smilei(...).Probe             ( ... , figure=1, vmin=None, vmax=None,
                                  xmin=None, xmax=None, ymin=None, ymax=None ).plot()
Smilei(...).ParticleDiagnostic( ... , figure=1, vmin=None, vmax=None,
                                  xmin=None, xmax=None, ymin=None, ymax=None ).plot()
\end{lstlisting}

\begin{itemize}
\item \code{figure} = \code{\_int\_}       (optional)\\*
	The figure number that is passed to matplotlib.\\*
	If absent, figure 1 is used.

\item \code{vmin} = \code{\_double\_}    (optional)\\*
	\code{vmax} = \code{\_double\_}    (optional)\\*
	If present, output value is rescaled before plotting.

\item \code{xmin} = \code{\_double\_}    (optional)\\*
	\code{xmax} = \code{\_double\_}    (optional)\\*
	\code{ymin} = \code{\_double\_}    (optional)\\*
	\code{ymax} = \code{\_double\_}    (optional)\\*
	If present, axes are rescaled before plotting.
\end{itemize}

If the data is \textbf{one}-dimensional, it is plotted as a \textbf{curve}, and is animated for all requested timesteps.\\
If the data is \textbf{two}-dimensional, it is plotted as a \textbf{map}, and is animated for all requested timesteps.\\
If the data is \textbf{zero}-dimensional, it is plotted as a \textbf{curve} as function of time.\\

\textbf{Example:}
\begin{lstlisting}
>>> S = Smilei("path/to/my/results")
>>> S.ParticleDiagnostic(diagNumber=1, figure=1, vmin=0, vmax=1e14 ).plot()
\end{lstlisting}
This will take the particle diagnostic \#1 and plot the resulting array in figure 1 from 0 to 3e14.
\clearpage


\section{To simultaneously plot multiple diagnostics in the same figure}
\begin{lstlisting}
multiPlot(diag1, diag2, ... , figure=1, shape=None)
\end{lstlisting}

\begin{itemize}
\item \code{diag1} = diagnostic prepared by \code{Scalar()}, \code{Field()}, \code{Probe()} or \code{ParticleDiagnostic()}\\*
	\code{diag2} = diagnostic prepared by \code{Scalar()}, \code{Field()}, \code{Probe()} or \code{ParticleDiagnostic()}\\*
	...

\item \code{figure} = \code{\_int\_}       (optional)\\*
	The figure number that is passed to matplotlib.\\*
	If absent, figure 1 is used.
	
\item \code{shape} = \code{[\_int\_ , \_int\_]}       (optional)\\*
	The arrangement of plots inside the figure. For instance, \code{[2, 1]} makes two plots stacked vertically, and \code{[1, 2]} makes two plots stacked horizontally.\\*
	If absent, stacks plots vertically.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}
>>> S = Smilei("path/to/my/results")
>>> A = S.Probe(probeNumber=0, field="Ex")
>>> B = S.ParticleDiagnostic(diagNumber=1)
>>> multiPlot( A, B, figure=1 )
\end{lstlisting}

This will plot the diagnostics \#0 and \#1 on the same figure, and make an animation for all available timesteps.


\section{Advanced plotting options}
In addition to \code{figure}, \code{vmin}, \code{vmax}, \code{xmin}, \code{xmax}, \code{ymin} and \code{ymax}, there are many more optional arguments. They are directly passed to the \textit{matplotlib} package.
\begin{itemize}
\item Options for the figure: \code{figsize},\code{dpi},\code{facecolor},\code{edgecolor}\\
	Please refer to \url{http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.figure}
\item Options for the axes frame: \code{aspect}, \code{axis\_bgcolor}, \code{frame\_on}, \code{position}, \code{title}, \code{visible},\\
	\code{xlabel}, \code{xscale}, \code{xticklabels}, \code{xticks}, \code{ylabel}, \code{yscale}, \code{yticklabels}, \code{yticks}, \code{zorder}\\
	Please refer to \url{http://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes.set}
\item Options for the lines: \code{color},\code{dashes},\code{drawstyle},\code{fillstyle},\code{label},\code{linestyle},\code{linewidth},\\
	\code{marker},\code{markeredgecolor},\code{markeredgewidth},\code{markerfacecolor},	\code{markerfacecoloralt},\\
	\code{markersize},\code{markevery},	\code{visible},\code{zorder}\\
	Please refer to \url{http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot}
\item Options for the image: \code{cmap},\code{aspect},\code{interpolation}\\
	Please refer to \url{http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.imshow}
\item Options for the colorbar: \code{cbaspect}, \code{orientation},\code{fraction},\code{pad},\code{shrink},\code{anchor},\code{panchor},\\
	\code{extend},\code{extendfrac},\code{extendrect},\code{spacing},\code{ticks},\code{format},\code{drawedges}\\
	Please refer to \url{http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.colorbar}
\item Options for the tick labels: \code{style\_x}, \code{scilimits\_x}, \code{useOffset\_x}, \code{style\_y}, \code{scilimits\_y}, \code{useOffset\_y}\\
	Please refer to \url{http://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes.ticklabel_format}
\end{itemize}
\textbf{Example:}\\
To choose a gray colormap of the image, use \code{cmap="gray"}.
\begin{lstlisting}
>>> S = Smilei("path/to/my/results")
>>> S.ParticleDiagnostic(0, figure=1, cmap="gray") .plot()
\end{lstlisting}
Many colormaps are available from the \textit{matplotlib} package. With \code{cmap=""}, you will get a list of available colormaps.


\section{Updating the plotting options}

You can change the plotting parameters using the \code{A.plot()} or the \code{A.set()} functions.\\
\textbf{Example:}
\begin{lstlisting}
>>> S = Smilei("path/to/my/results")
>>> A = ParticleDiagnostic(diagNumber=0, figure=1, vmax=1)
>>> A.plot( figure=2 )
>>> A.set( vmax=2 )
>>> A.plot()
\end{lstlisting}


\section{Alternative syntax}

Instead of \code{S = Smilei("path/to/my/results")}, you can directly choose which simulation you would like to use
by specifying the \code{results\_path} parameter as the first argument when calling a diagnostic.\\
\\
For example, instead of 
\begin{lstlisting}
>>> S = Smilei("path/to/my/results")
>>> A = S.ParticleDiagnostic(0)
\end{lstlisting}
you may use
\begin{lstlisting}
>>> A = ParticleDiagnostic("path/to/my/results", 0)
\end{lstlisting}

WARNING: this syntax can be much slower than the official one.

\clearpage


%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tutorial}

If you don't know how to run SMILEI, please refer to the appropriate documentation first. The commands can vary depending on your system and installation. A typical example of the command to run SMILEI is: \code{mpiexec -np 1 smilei mycase.py}\\*

\subsection{Running the test case}

In the \code{benchmarks} directory, we provide a test case \code{tst1d\_6\_particle\_diagnostic.py}. This case is very simple: it consists of a one-dimensional uniform neutral plasma composed by ions and electrons. The electrons all have a drift velocity of $0.05c$.\\*

Run this case using SMILEI and collect the results in a directory of your choice. In this tutorial, we suppose that the results are in the directory \code{tst1d\_6\_particle\_diagnostic}. Make sure this directory contains the input file \code{tst1d\_6\_particle\_diagnostic.py} and the output files \code{ParticleDiagnostic0.h5}, \code{ParticleDiagnostic1.h5}, etc.\\*

An example of the commands you may use from a UNIX \textit{terminal} (or \textit{console}) is
\begin{lstlisting}
$ mkdir tst1d_6_particle_diagnostic
$ cp   benchmarks/tst1d_6_particle_diagnostic.py    tst1d_6_particle_diagnostic
$ cd tst1d_6_particle_diagnostic
$ mpiexec -np 1 smilei tst1d_6_particle_diagnostic.py
$ cd ..
\end{lstlisting}

\subsection{Starting \textit{python} and listing available diagnostics}

From the same terminal, launch \textit{python} using the command
\begin{lstlisting}
$ python -i scripts/Diagnostics.py
\end{lstlisting}

Your are now in the \textit{python} prompt.\\*
Obtain a list of available particle diagnostics using
\begin{lstlisting}
>>> S = Smilei('tst1d_6_particle_diagnostic')
>>> S.ParticleDiagnostic()
Printing available particle diagnostics:
----------------------------------------
Diag#0 - density of species # 1 
    Every 4 timesteps, averaging over 2 timesteps
    x from 0.0 to 6.28319 in 100 steps 
    vx from -0.1 to 0.1 in 100 steps 
Diag#1 - density of species # 0 
    Every 4 timesteps, no time-averaging
    x from 0.0 to 6.28319 in 100 steps 
    vx from -0.001 to 0.001 in 100 steps 
Diag#2 - density of species # 1 
    Every 10 timesteps, averaging over 5 timesteps
    ekin from 0.0001 to 0.1 in 100 steps  [ LOG SCALE ] 
\end{lstlisting}

Look at the diagnostic \#0: it is the density of species \#1 (here, electrons) with two
axes: the position $x$ and the velocity $v_x$. In other words, it is the phase-space of electrons.

\subsection{Plot a diagnostic result at $t=0$}
To plot the phase-space in the initial conditions, use 
\begin{lstlisting}
>>> S.ParticleDiagnostic(0, timesteps=0 ).plot()
\end{lstlisting}
A window appears (see Figure \ref{Tuto1}). We can see that the electrons have indeed a drift velocity of $0.05c$.\\*

To obtain the equivalent plot for the ions, use the diagnostic \#1 with the command
\begin{lstlisting}
>>> S.ParticleDiagnostic(1, timesteps=0 ).plot()
\end{lstlisting}
This results in the plot in Figure \ref{Tuto2}. The ions have a zero average velocity.\\*

\begin{figure}[htbp]
\centering
\begin{minipage}[b]{.46\linewidth}
\includegraphics[width=7cm]{ParticleDiagTutorial1.png}
\caption{Phase-space of electrons at $t=0$.}
\label{Tuto1}
\end{minipage}
\hfill{}
\begin{minipage}[b]{.46\linewidth}
\includegraphics[width=7cm]{ParticleDiagTutorial2}
\caption{Phase-space of ions at $t=0$.}
\label{Tuto2}
\end{minipage}
\end{figure}



\subsection{Plot sections (``slices'') of the array}

The diagnostic \#0 that we plotted in Figure \ref{Tuto1} is the electron phase-space.
Let us say we want to sum over the data that is contained between $x=3$ and 4, and plot the result as a function of $v_x$.
This is achieved by the argument \code{slice}:
\begin{lstlisting}
>>> S.ParticleDiagnostic(0, timesteps=0, slice={"x":[3,4]} ).plot()
\end{lstlisting}
The result is shown in Figure \ref{Tuto3}. We can see that the peak is located at $v_x=0.05c$, as we have already found before.\\*

\begin{figure}[htbp]
\centering
\begin{minipage}[b]{.46\linewidth}
\includegraphics[width=7cm]{ParticleDiagTutorial3}
\caption{$v_x$ distribution of electrons contained between $x=3$ and 4, at $t=0$.}
\label{Tuto3}
\end{minipage}
\hfill{}
\begin{minipage}[b]{.46\linewidth}
\includegraphics[width=7cm]{ParticleDiagTutorial4}
\caption{$x$ distribution of electrons contained between $v_x=-0.1$ and $0.1$, at $t=0$.}
\label{Tuto4}
\end{minipage}
\end{figure}

Now, let us do the slice on $v_x$ instead of $x$.
\begin{lstlisting}
>>> S.ParticleDiagnostic(0, timesteps=0, slice={"vx":"all"}
                         ).plot(vmin=0, vmax=11)
\end{lstlisting}
By choosing \code{"all"} in the argument \code{slice}, all the velocities $v_x$ are sliced.
In our case, as our diagnostic goes from $v_x=-0.1$ to $0.1$, these limits are used.\\*
Note that parameters \code{vmin} and \code{vmax} are used to have a nicer plot.\\*
The result is shown in Figure \ref{Tuto4}. We obtain a constant density of 10$n_c$, which is what was chosen in the input file.

\subsection{Make animated plots}
To have an animation of the electron phase-space with time, you have to remove the \code{timesteps} argument:
\begin{lstlisting}
>>> S.ParticleDiagnostic( 0 ).plot()
\end{lstlisting}
You will see the electron velocity oscillate from $0.05c$ to $-0.05c$. This is due to the fact that we are simulating a plasma wave with infinite wavelength.\\*

Note that all the available timesteps are animated. If you want to only animate between timesteps 20 and 60, use
\begin{lstlisting}
>>> S.ParticleDiagnostic( 0, timesteps=[20,60] ).plot()
\end{lstlisting}


\subsection{Make multiple plots on the same figure}

Use the following commands to have the animation with both electrons and ions on the same figure:
\begin{lstlisting}
>>> A = S.ParticleDiagnostic( 0 )
>>> B = S.ParticleDiagnostic( 1 )
>>> multiPlot(A, B, shape=[1,2])
\end{lstlisting}
A snapshot of this double plot is given in Figure \ref{Tuto5}.\\*\\*

If the two plots are 1D, and are both of the same type, then they will automatically be plotted on the same axes.
\begin{lstlisting}
>>> A = S.ParticleDiagnostic(0,slice={"x":"all"})
>>> B = S.ParticleDiagnostic(1,slice={"x":"all"})
>>> multiPlot(A, B)
\end{lstlisting}
This is shown in Figure \ref{Tuto6} where you can see the two curves in blue and green.\\*\\*

\begin{figure}[htbp]
\centering
\begin{minipage}[b]{.48\linewidth}
\includegraphics[width=10cm]{ParticleDiagTutorial5}
\caption{Two plots on the same figure.}
\label{Tuto5}
\end{minipage}
\hfill{}
\begin{minipage}[b]{.38\linewidth}
\includegraphics[width=6cm]{ParticleDiagTutorial6}
\caption{Two curves in the same axes.}
\label{Tuto6}
\end{minipage}
\end{figure}


\subsection{Make a plot as a function of time}
If you have sliced all the axes, then you obtain a 0-dimensional array (a scalar). In this case, the plots are automatically done 
as a function of time (they are not animated).\\*
In our case, use
\begin{lstlisting}
>>> A=S.ParticleDiagnostic(3, slice={"ekin":"all"})
>>> B=S.ParticleDiagnostic(3, slice={"ekin":[0,0.001]})
>>> multiPlot(A,B)
\end{lstlisting}

\begin{wrapfigure}{r}{80mm}
  \centering
  \includegraphics[width=6.5cm]{ParticleDiagTutorial7}
  \caption{Blue: total density \emph{vs} time. Green: density of slow electrons \emph{vs} time.}
  \label{Tuto7}
\end{wrapfigure}
The diagnostic that we employ here (\#3) is the energy spectrum of electrons: the axis is along \code{ekin} which is the kinetic energy. In the first line of the code above, we are using a slice \code{"ekin":"all"}. Consequently, all the electrons, with all energies, will be summed, thus obtaining a scalar value equal to the total plasma density. In the second line of code, we are using \code{"ekin":[0,0.001]}, which means that only the electrons below 0.511 keV are considered.\\*
Both these quantities \code{A} and \code{B} are scalars, not arrays: they will be plotted as a function of time. This is shown in Figure \ref{Tuto7} where you can see \code{A} in blue and \code{B} in green. \code{A} represents all the electrons, and indeed, their density is constant. \code{B} represents only the slower electrons, and their number varies in time because, as we have seen before, all electrons oscillate and they do not have a constant energy. This appears on the green curve as an oscillating density.



\subsection{Make an operation between diagnostics}
Let us consider again the diagnostic \#0, which is the density of electrons as a function of $x$ an $v_x$. Diagnostic \#2 is very similar to \#0 as it has the same axes $x$ and $v_x$, but it has \code{ouput=px\_density} instead of \code{ouput=density}. Consequently, if we divide \#2 by \#0, we will obtain the average value of $p_x$ as a function of $x$ an $v_x$. To do this operation, we need to indicate \code{"\#2/\#0"} instead of the diagnostic number:
\begin{lstlisting}
>>> S.ParticleDiagnostic("#2/#0").plot()
\end{lstlisting}
We obtain the plot of Figure \ref{Tuto8}, which is actually not very helpful because $\left<p_x\right>$ varies with $v_x$. To have something nicer, let us slice all axes with \code{slice=\{"x":"all","vx":"all"\}}.
\begin{lstlisting}
>>> S.ParticleDiagnostic("#2/#0", slice={"x":"all","vx":"all"}).plot()
\end{lstlisting}
We obtain Figure \ref{Tuto9} which nicely shows the average $p_x$ as a function of time. This value oscillates, as we have seen previously.


\begin{figure}[htbp]
\centering
\begin{minipage}[b]{.48\linewidth}
\includegraphics[width=7.5cm]{ParticleDiagTutorial8}
\caption{$\left<p_x\right>$ as a function of $x$ and $v_x$.}
\label{Tuto8}
\end{minipage}
\hfill{}
\begin{minipage}[b]{.48\linewidth}
\includegraphics[width=7.3cm]{ParticleDiagTutorial9}
\caption{$\left<p_x\right>$ as a function of time.}
\label{Tuto9}
\end{minipage}
\end{figure}




\end{document}


