\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage[margin=2cm]{geometry}
\usepackage{fancyvrb,xcolor}
\usepackage[urlcolor=blue,linkcolor=black,colorlinks=true]{hyperref}
\urlstyle{rm}
\usepackage{wrapfig}
\usepackage{tabu}
\usepackage{longtable}
\usepackage{xspace}

\setlength\parindent{0pt}
\setlength{\parskip}{10pt}

\newcommand{\code}[1]{\colorbox{yellow!15}{\ttfamily #1}}
\newcommand{\val}[1]{{\ttfamily \textit{#1}}}
\newcommand{\blue}[1]{{\color{blue} #1}}

\newcommand{\python}{\emph{python}\xspace}
\newcommand{\smilei}{\emph{SMILEI}\xspace}
\newcommand{\cpp}{\emph{C++}\xspace}
\newcommand{\todo}{{\color{red}TODO}}

\usepackage{listings}
\lstset{backgroundcolor=\color{yellow!15}, basicstyle=\ttfamily, columns=fullflexible, keepspaces=true,escapeinside={<>}{<>}}


%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\vfill

\title{Namelist syntax in \smilei}
\maketitle

\vfill

In \smilei, the input file (\emph{namelist}) is written in the \python  language.
It is thus recommended to know the basics of \python.

To create a namelist, we suggest you copy one existing file in the folder \emph{benchmarks}. All namelists have the extension \code{.py}.

\vfill
\begingroup
\setlength{\parskip}{0pt}
\setcounter{tocdepth}{2}
\tableofcontents
\endgroup
\vfill

\clearpage



%%%%%%%%%%%%%%%%%%%%%%%
\section{General rules for writing a namelist}

\begin{itemize}
\item The namelist must define variables that \smilei will understand.\\
For instance, \code{timestep = 0.01}.\\
All \python operations are valid. For instance: \code{timestep = 40*0.0001}.

\item Each instruction must be written on a new line.

\item The \python syntax requires special indentation of each line. You begin with no indentation,
but you have to \textbf{add four spaces at the beginning of lines inside a group}, and so on.
For instance:
\begin{lstlisting}
if a == 0:
    timestep = 0.1
    if b == 1:
        timestep = 0.2
else:
    timestep = 0.3
\end{lstlisting}

\item You will need to use \emph{lists}, which are series of things in \python, defined between brackets \code{[]} and separated by commas. For example, \code{mean\_velocity = [0., 1.1, 3.]}.

\item You are free to import any \python package into the namelist.\\
For instance, you may obtain $\pi$ using \code{from math import pi}.

\item \textbf{Important note}: \smilei normalizes lengths and times to arbitrary values $L_0$ and $T_0 = L_0/c$.  All lengths and times defined in the namelist are given in units of $L_0$ and $T_0$.

\item In this document, variables \blue{highlighted in blue} are optional.

\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%
\section{Stopping and restarting the code}

\begin{itemize}

\item \code{\blue{dump\_step}}, integer, default is \code{0}\\
The number of timesteps between each dump of the full simulation. If \code{0}, no dump is done.

\item \code{\blue{dump\_minutes}}, float, default is \code{0.}\\
The number of minutes between each dump of the full simulation (combines with \code{dump\_step}). If \code{0.}, no dump is done.

\item \code{\blue{exit\_after\_dump}}, boolean, default is \code{True}\\
If \code{True}, the code stops after the dump.

\item \code{\blue{restart}}, boolean, default is \code{False}\\
If \code{True}, \smilei finds the last dump file and loads the corresponding simulation. If the dump
file is not found, an error is raised.

\item \code{\blue{dump\_file\_sequence}}, \todo

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%
\section{Spatial and temporal scales}

\begin{itemize}

\item \code{geometry}, equal to \code{"1d3v"} or \code{"2d3v"}\\
The geometry of the simulation: \code{1d} or \code{2d} correspond to the number of spatial dimensions, and \code{3v} indicates the number of dimensions for velocities.

\item \code{\blue{interpolation\_order}}, integer, default is \code{2}\\
Interpolation order. To this day, only \code{2} is available.

\item \code{timestep}, float\\
Duration of one timestep in units of $T_0$.

\item \code{sim\_time}, float\\
Duration of the simulation in units of $T_0$.

\item \code{cell\_length}, list of floats\\
Dimensions of one cell in units of $L_0$. The number of elements of this list must be the same as the dimension of the simulation.

\item \code{sim\_length}, list of floats\\
Dimensions of the simulations in units of $L_0$. The number of elements of this list must be the same as the dimension of the simulation.

\item \code{\blue{time\_fields\_frozen}}, float, default is \code{0.}\\
Time, at the beginning of the simulation, during which fields are frozen.

\item
\code{bc\_em\_type\_x}, list of two strings: \code{["\val{bc\_xmin}", "\val{bc\_xmax}"]}\\
\code{bc\_em\_type\_y}, list of two strings: \code{["\val{bc\_ymin}", "\val{bc\_ymax}"]}\\
The type of boundary conditions for the electromagnetic fields. You must indicate, instead of
 \val{bc\_xmin}, \val{bc\_xmax}, \val{bc\_ymin} and \val{bc\_ymax}, one of the following 
 choices: \code{periodic}, \code{silver-muller}, or \code{reflective}. Default is \code{periodic}.

\item \code{\blue{clrw}}, float, default is \code{0.}\\
Cluster width.
\todo

\item \code{\blue{wavelength\_SI}}, float\\
The value of the wavelength $\lambda_0$ in SI units (\textbf{only required if collisions or ionization are requested}). The wavelength is related to the normalization length according to  $2\pi L_0 = \lambda_0$.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%
\section{Moving window}

\begin{itemize}

\item \code{\blue{nspace\_win\_x}}, int, default is \code{0}\\
\todo

\item \code{\blue{t\_move\_win}}, float, default is \code{0.}\\
\todo

\item \code{\blue{vx\_win}}, float, default is \code{0.}\\
\todo

\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%
\section{Species}

Each species has to be defined in a \code{Species()} block, for instance:
\begin{lstlisting}
Species(
	species_type = "electron",
	initPosition_type = "regular",
	initMomentum_type = "maxwell-juettner",
	n_part_per_cell = 1000,
	mass = 1.,
	charge = 1.,
	nb_density = 10.,
	bc_part_type_west = "none",
	bc_part_type_east = "none"
)
\end{lstlisting}

All the possible variables inside this block are explained here:
\vspace{-10pt}
\begin{itemize}

\item \code{species\_type}, string\\
The name you want to give to this species.

\item \code{initPosition\_type}, equal to \code{"regular"} or \code{"random"}\\
The initialization of particle positions: regularly spaced, or randomly distributed.

\item \code{initMomentum\_type}, equal to \code{"maxwell-juettner"}, \code{"cold"} or \code{"rectangular"}\\
The initialization of particle momenta: Maxwell-J\"uttner, cold, or rectangular distribution.
These distributions depend on the parameter \code{temperature} explained below.

\item \code{mass}, float\\
The mass of particles, in units of the electron mass $m_e$.

\item \code{\blue{atomic\_number}}, int\\
The atomic number of the particles, required only if ionization is requested. \todo

\item \code{nb\_density}, float or \python function (see section \ref{sec:profiles})\\
\code{charge\_density}, float or \python function (see section \ref{sec:profiles})\\
The \underline{absolute value} of the number density or charge density (choose one only) of the particle distribution, 
in units of the critical density $n_c=\varepsilon_0 m_e/(e^2 T_0^2)$.

\item \code{charge}, float or \python function (see section \ref{sec:profiles})\\
The particle charge, in units of the electron charge $e$.

\item \code{\blue{mean\_velocity}}, a list of floats or \python functions (see section \ref{sec:profiles})\\
The initial drift velocity of the particles, in units of the speed of light $c$.

\item \code{\blue{temperature}}, a list of floats or \python functions (see section \ref{sec:profiles})\\
The initial temperature of the particles, in units of $m_ec^2$.

\item \code{n\_part\_per\_cell}, float or \python function (see section \ref{sec:profiles})\\
The number of particles per cell.

\item \code{bc\_part\_type\_west}, string\\
\code{bc\_part\_type\_east}, string\\
\code{bc\_part\_type\_south}, string\\
\code{bc\_part\_type\_north}, string\\
The boundary condition for particles: \code{"none"} means periodic. \todo

\item \code{\blue{time\_frozen}}, float, default is \code{0.}\\
The time during which the particle positions are not updated, in units of $T_0$.

\item \code{\blue{ionization\_model}}, string, default is \code{"none"}\\
\todo

\item \code{\blue{radiating}}, boolean, default is \code{False}\\
\todo

\item \code{\blue{isTest}}, boolean, default is \code{False}\\
Flag for test particles. If \code{True}, this species will contain only test particles
which do not participate in the charge and currents.

\item \code{\blue{c\_part\_max}}\\
\todo

\item \code{\blue{dynamics\_type}}\\
\todo


\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%
\section{External fields}

External fields can be applied using a \code{ExtField()} block, for instance:
\begin{lstlisting}
ExtField(
    field = "Ex",
    profile = constant(0.01, xvacuum=0.1)
)
\end{lstlisting}

All the possible variables inside this block are explained here:
\vspace{-10pt}
\begin{itemize}

\item \code{field}, string\\
The name of the field: \code{"Ex"}, \code{"Ey"}, \code{"Ez"}, \code{"Bx"}, \code{"By"} or \code{"Bz"}.

\item \code{profile}, float or \python function (see section \ref{sec:profiles})\\
The initial spatial profile of the applied field. The units are the natural normalization units for fields, i.e., $B_0=m_e /(eT_0)$ for magnetic fields, and $E_0=m_e c/(eT_0)$ for electric fields.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%
\section{Spatial profiles\label{sec:profiles}}

Several quantities require the input of a spatial profile:
\begin{itemize}
\item The average particle charge.
\item The charge density or number density.
\item The drift velocity.
\item The temperature (only for distributions which require a temperature value).
\item The number of particles per cell.
\item Any external field.
\end{itemize}

There are many ways to define a profile.

\subsection{Constant profiles}
You may decide to have a constant profile: a constant value over the whole box.
In this case, it is very easy: you do not need to define a profile.

\begin{itemize}

\item \code{Species( ... , charge = -3., ... )} defines a species with charge $Z^\star=3$ for all its particles.

\item \code{Species( ... , nb\_density = 10., ... )} defines a species with density $10\,n_c$.
You can choose \code{nb\_density} (\textit{number density}) or \code{charge\_density}

\item \code{Species( ... , mean\_velocity = [0.05, 0., 0.], ... )} defines a species with drift velocity $v_x = 0.05\,c$ over the whole box.

\item \code{Species(..., initMomentum\_type="maxwell-juettner", temperature=[1e-5], ...)} defines a species with a Maxwell-J\"uttner distribution of temperature $T = 10^{-5}\,m_ec^2$ over the whole box.
Note that the temperature may be anisotropic: \code{temperature=[1e-5, 2e-5, 2e-5]}.

\item \code{Species( ... , n\_part\_per\_cell = 10., ... )} defines a species with 10 particles per cell.

\item \code{ExtField( field="Bx", profile=0.1 )} defines a constant external field $B_x = 0.1 B_0$.

\end{itemize}


 \subsection{\python profiles}
 Any \python function can be a profile. You must have basic \python knowledge to build these functions. Examples:
\begin{lstlisting}
def f(x):
	if x<1.: return 0.
	else: return 1.
\end{lstlisting}
\begin{lstlisting}
def f(x,y):    # two variables for 2D simulation
	import math
	twoPI = 2.* math.pi
	return math.cos(  twoPI * x/3.2 )
\end{lstlisting}
\begin{lstlisting}
f = lambda x: x**2 - 1
\end{lstlisting}

Once the function is created, you have to include it in the block you want:
\begin{lstlisting}
Species( ... , charge = f, ... )
\end{lstlisting}
\begin{lstlisting}
Species( ... , nb_density = f, ... )
\end{lstlisting}
\begin{lstlisting}
Species( ... , mean_velocity = [f, f, f], ... )
\end{lstlisting}
\begin{lstlisting}
Species( ... , temperature = [f, f, f],	... )
\end{lstlisting}
\begin{lstlisting}
Species( ... , n_part_per_cell = f, ... )
\end{lstlisting}
\begin{lstlisting}
ExtField( ... , profile = f, ... )
\end{lstlisting}

\subsection{Built-in \python functions\label{sec:pyprofiles}}
\smilei provides some \python functions to help you build your profiles.
\vspace{10pt}


\begingroup
\setlength{\parskip}{0pt}
To define a \underline{constant profile}:
\begin{lstlisting}
<>constant(value, xvacuum=0., yvacuum=0.)<>
\end{lstlisting}
\code{value} defines the magnitude.\\
\code{xvacuum} and \code{yvacuum} are vacuum regions before the start of the profile.
\vspace{10pt}

To define a \underline{trapezoidal profile}:
\begin{lstlisting}
<>trapezoidal(max,<>
            <>xvacuum=0., xplateau=None, xslope1=0., xslope2=0.,<>
            <>yvacuum=0., yplateau=None, yslope1=0., yslope2=0. )<>
\end{lstlisting}
\code{max} is the maximum value, \code{xvacuum} is the empty length before the ramp up,
\code{xplateau} is the length of the plateau (default is {\ttfamily sim\_length - xvacuum}),
\code{xslope1} is the length of the ramp up and \code{xslope2} is the length of the ramp down.
The other arguments are the same, but for a 2D simulation.\\
\vspace{10pt}

To define a \underline{gaussian profile}:
\begin{lstlisting}
<>gaussian(max,<>
         <>xvacuum=0., xlength=None, xfwhm=None, xcenter=None, xorder=2,<>
         <>yvacuum=0., ylength=None, yfwhm=None, ycenter=None, yorder=2 )<>
\end{lstlisting}
\code{max} is the maximum value, \code{xvacuum} is the empty length before starting the profile,
\code{xlength} is the length of the profile (default is {\ttfamily sim\_length - xvacuum}),
\code{xfwhm} is the gaussian FWHM (default is {\ttfamily xlength/3.}),
\code{xcenter} is the gaussian center position (default is in the middle of {\ttfamily xlength}
and \code{xorder} is the order of the gaussian.
The other arguments are the same, but for a 2D simulation. If \code{yorder==0}, then the profile is constant over $y$.\\
\vspace{10pt}

To define a \underline{polygonal profile}:
\begin{lstlisting}
polygonal( xpoints=[], xvalues=[] )
\end{lstlisting}
where \code{xpoints} is a list defining the position of points, and \code{xvalues} is
a list defining the values of the profile at each point.\\
\vspace{10pt}

To define a \underline{cosine profile}:
\begin{lstlisting}
<>cosine( base, amplitude=1.,
                       xvacuum=0., xlength=None, phi=0., xnumber=1 )
\end{lstlisting}
\code{base} is an offset of the profile value, \code{amplitude} is the amplitude of the cosine,
\code{xvacuum} is the empty length before starting the profile,
\code{xlength} is the length of the profile (default is {\ttfamily sim\_length - xvacuum}),
\code{phi} is the phase offset
and \code{xnumber} is the number of periods within \code{xlength}.\\
\vspace{10pt}

\textbf{Example:}
\begin{lstlisting}
Species( ... ,
	density = gaussian(10., xfwhm=0.3, xcenter=0.8),
	... )
\end{lstlisting}
\vspace{10pt}

\textbf{Illustration of the built-in profiles}
{
\center
\includegraphics[width=17cm]{pythonprofiles.pdf} 
}
\endgroup


%%%%%%%%%%%%%%%%%%%%%%%
\section{Lasers \label{sec:laser}}
\todo


%%%%%%%%%%%%%%%%%%%%%%%
\section{Collisions}

To have binary collisions in \smilei, add one or several copies of the following block in the input file:
\begin{lstlisting}
Collisions(
	species1 = <>["\textit{species\_name}",  "\textit{species\_name}",  ...]<>,
	species2 = <>["\textit{species\_name}",  "\textit{species\_name}",  ...]<>,
	<>\blue{coulomb\_log = \textit{ln}$\Lambda$}<>,
	<>\blue{debug\_every = \textit{every}}<>
)
\end{lstlisting}

Each \val{species\_name} must be the name of an existing species. This name can be
found in the input file inside any block \code{Species(...)} under the keyword \code{species\_type}.

The collisions will occur between (1) all species under the group \code{species1} and (2) all species under the group \code{species2}.
For instance, to have collisions between \code{electrons1} and \code{ions1} , use
\begin{lstlisting}
	species1 = ["electrons1"],
	species2 = ["ions1"]
\end{lstlisting}
Other example:
\begin{lstlisting}
	species1 = ["electrons1", "electrons2"],
	species2 = ["ions"]
\end{lstlisting}
will collide all electrons with ions.
\textbf{WARNING: this does not make \code{electrons1} collide with \code{electrons2}.}

The two groups of species have to be \underline{completely different} OR \underline{exactly equal}.
In other words, if \code{species1} is not equal to \code{species2}, then they cannot have any common species.
If the two groups are exactly equal, we call this situation ``intra-collisions''.

The \blue{optional} value \val{ln$\Lambda$} must be a float.\vspace{-10pt}
\begin{itemize}
	\item If \val{ln$\Lambda$} $=0$, the Coulomb logarithm is automatically computed for each collision (default).
	\item If \val{ln$\Lambda$} $>0$, the Coulomb logarithm is equal to this value.
\end{itemize}

The \blue{optional} value \val{debug\_every} must be an integer: the number of timesteps between
each output of information about collisions. If absent or zero, there will be no outputs.

For more details about the collision scheme in \smilei, please refer to the corresponding documentation.



%%%%%%%%%%%%%%%%%%%%%%%
\section{Diagnostics}
Several types of diagnostics are available in \smilei. Another documentation explains how to post-process them.

\subsection{Scalars\label{sec:scalars}}

SMILEI can collect various scalar data, such as total particle energy, total field energy, etc.
This is done if the following block is included in the input file.

\begin{lstlisting}
Scalar( every = <>\val{every}<>,
	<>\blue{tmin      = \val{tmin}}<>,
	<>\blue{tmax      = \val{tmax}}<>,
	<>\blue{precision = \val{precision}}<> )
\end{lstlisting}
\vspace{-1em}
\begin{itemize}
\item\val{every} is the number of timesteps between each output.
\item\val{tmin} and \val{tmax} (\blue{optional}) are the min and max times that will be used.
\item\val{precision} (\blue{optional}) is the number of digits of the outputs. Default = 10.
\end{itemize}

In the input file, you may add the following block as a reminder.
\begin{lstlisting}
# DIAGNOSTICS ON SCALARS
# every = integer, number of time-steps between each output
# tmin and tmax = floats, min and max times that will be used
# precision = integer, number of digits of the outputs. Default = 10
\end{lstlisting}

The full list of scalars is:\\
\vspace{-0.7em}

\begin{longtabu}{X r | l X}
&	 & {\bf Global energies}& \\
&Utot & Total energy& \\
&Ukin&  Total kinetic energy in the particles&\\
&Uelm& Total electromagnetic energy in the EM-fields&\\
&Uexp& Expected value for the total energy (Initial energy $\pm$ energy lost or gained)&\\
&Ubal& Energy balance (Total energy - Expected energy)&\\
&Ubal\_norm& Normalized energy balance (${\rm Ubal/Utot}$)&\\
& & & \\
&	 & {\bf Energies lost/gained at boundaries \& due to moving window}& \\
&Ukin\_bnd& Kinetic energy exchanged at the boundaries during the timestep &\\
&Uelm\_bnd& Electromagnetic energy exchanged at the boundaries during the timestep &\\
&Ukin\_out\_mvw& Kinetic energy lost during the timestep due to the moving window&\\
&Ukin\_inj\_mvw& Kinetic energy injected during the timestep due to the moving window&\\
&Uelm\_out\_mvw& Electromagnetic energy lost during the timestep due to the moving window&\\
&Uelm\_inj\_mvw& Electromagnetic energy injected during the timestep due to the moving window&\\
& & & \\
&	 & {\bf Energies lost/gained at boundaries \& due to moving window}& \\
& Ebal\_norm & Ebalance $/$ Etot &\\
& Ebalance & Current energy $-$ initial total energy&\\
& Elost & Lost particle energy during last timestep &\\
& Poynting & Accumulated Poyting flux through all boundaries&\\
& & & \\
& Z\_abc & Average charge of species "abc" &\\
& E\_abc & ... their kinetic energy &\\
& N\_abc & ... and number of particles &\\
& & & \\
& Ex\_U & $\int E_x^2 dV /2$ & \\
& & ... and similar for fields Ey, Ez, Bx\_m, By\_m and Bz\_m & \\
& & & \\
& ExMin & Minimum of $E_x$ & \\
& ExMinCell &  ... and its location (cell index) & \\
& ExMax & Maximum of $E_x$ & \\
& ExMaxCell &  ... and its location (cell index) & \\
& & ... and same things for fields Ey, Ez, Bx\_m, By\_m, Bz\_m, Jx, Jy, Jz and Rho & \\
& & & \\
& PoyEast & Accumulated Poynting flux through eastern boundary & \\
& PoyEastInst & Current Poynting flux through eastern boundary & \\
& & ... and same things for boundaries West, South, North, Bottom, Top &\\
\end{longtabu}


\subsection{Fields\label{sec:fields}}

SMILEI can collect various field data (electric fields, magnetic fields, currents and density)
taken at the location of the PIC grid, both as instantaneous values and averaged values.
This is done if the following instructions are included in the input file.
\begin{lstlisting}
fieldDump_every    = <>\val{every}<>
avgfieldDump_every = <>\val{every\_avg}<>
ntime_step_avg     = <>\val{t\_avg}<>
\end{lstlisting}\vspace{-10pt}
where\vspace{-10pt}
\begin{itemize}
\item \val{every} is the number of timesteps between each output of the instantaneous fields.
\item \val{every\_avg} is the number of timesteps between each output of the time-averaged fields.
\item \val{t\_avg} is the number of timesteps for time-averaging.
\end{itemize}
The full list of fields is:
\begin{longtabu}{X r | l X}
& Bx\_m &  & \\
& By\_m &  Components of the magnetic field & \\
& Bz\_m &  & \\
& & & \\
& Ex &  & \\
& Ey & Components of the electric field & \\
& Ez &  & \\
& & & \\
& Jx &  & \\
& Jy & Components of the total current & \\
& Jz &  & \\
& & & \\
& Jx\_abc &  & \\
& Jy\_abc & Components of the current due to species "abc" & \\
& Jz\_abc &  & \\
& & & \\
& Rho & Total density & \\
& Rho\_abc & Density of species "abc" & \\
\end{longtabu}


\subsection{Probes\label{sec:probes}}

The fields from the previous section are taken at the PIC grid locations, but it is also possible to obtain
the fields at arbitrary locations. These are called \textit{probes}.

The probes interpolate the fields at either one point (0-D), several points arranged in a line (1-D) or several points arranged in a mesh (2-D).

To add one probe diagnostic in the input file, there are several cases:\\
For only one point (zero-dimensional probe)
\begin{lstlisting}
DiagProbe(
    every      = <>\val{every}<>,
    pos        = [<>\val{x0}, \blue{\val{y0}, \val{z0}}<>]
)
\end{lstlisting}\vspace{-10pt}
where\vspace{-10pt}
\begin{itemize}
\item \val{every} is the number of timesteps between each output.
\item \val{x0}, \val{y0}, \val{z0} is the position of the point where to interpolate the fields.\\
\textbf{Note that \val{y0} (or \val{z0}) should only be used in the case of a 2-D (or 3-D) simulation.}
\end{itemize}

For a series of points arranged in a line (one-dimensional probe)
\begin{lstlisting}
DiagProbe(
    every      = <>\val{every}<>,
    pos        = [<>\val{x0}, \blue{\val{y0}, \val{z0}}<>],
    pos_first  = [<>\val{x1}, \blue{\val{y1}, \val{z1}}<>],
    number     = [<>\val{n1}<>]
)
\end{lstlisting}\vspace{-10pt}
where\vspace{-10pt}
\begin{itemize}
\item \val{x0}, \val{y0}, \val{z0} is the position of the starting point of the line.
\item \val{x1}, \val{y1}, \val{z1} is the position of the ending point of the line.
\item \val{n1} is the number of points along this line.
\end{itemize}

For a series of points arranged in a mesh (two-dimensional probe)
\begin{lstlisting}
DiagProbe(
    every      = <>\val{every}<>,
    pos        = [<>\val{x0}, \blue{\val{y0}, \val{z0}}<>],
    pos_first  = [<>\val{x1}, \blue{\val{y1}, \val{z1}}<>],
    pos_second = [<>\val{x2}, \blue{\val{y2}, \val{z2}}<>],
    number     = [<>\val{n1}, \val{n2}<>]
)
\end{lstlisting}\vspace{-10pt}
In this case, the three points define three vertices of a paralellogram.

\subsubsection*{Notes}
\begin{itemize}
\item Probes only output the electromagnetic fields, the total current and the total density.
\item The dimension of the probe is decided only by the instruction \code{number}: without it, the probe is 0-D, with \code{number = [\val{n1}]}, the probe is 1-D, and with \code{number =  [\val{n1}, \val{n2}]}, the probe is 2-D.
\item You can have several probes in the input file.
\end{itemize}


\subsubsection*{Examples of probe diagnostics}

0-D probe in 1-D simulation
\begin{lstlisting}
DiagProbe(
    every = 1,
    pos   = [1.2]
)
\end{lstlisting}

1-D probe in 1-D simulation
\begin{lstlisting}
DiagProbe(
    every = 1,
    pos       = [1.2],
    pos_first = [5.6],
    number    = [100]
)
\end{lstlisting}

1-D probe in 2-D simulation
\begin{lstlisting}
DiagProbe(
    every = 1,
    pos       = [1.2,  4.],
    pos_first = [5.6,  4.],
    number    = [100]
)
\end{lstlisting}

2-D probe in 2-D simulation
\begin{lstlisting}
DiagProbe(
    every = 1,
    pos        = [0. ,   0.],
    pos_first  = [10. ,  0.],
    pos_second = [0.,    10.],
    number     = [100,   100]
)
\end{lstlisting}



\subsection{Particle diagnostics}

A \textit{particle diagnostic} can collect data from the macro-particles and processes them during runtime.
It does \underline{not} provide information on individual particles: instead, it produces
\underline{averaged quantities} like the particle density, currents, etc.

The data may be collected from one or several particle species.

The data is discretized inside a ``grid'' chosen by the user. This grid may be of any dimension.
Examples:
\begin{itemize}
\item 1-dimensional grid along the position $x$ (gives density variation along $x$)
\item 2-dimensional grid along positions $x$ and $y$ (gives density map)
\item 1-dimensional grid along the velocity $v_x$ (gives the velocity distribution)
\item 2-dimensional grid along position $x$ and momentum $p_x$ (gives the phase-space)
\item 1-dimensional grid along the kinetic energy $E_\mathrm{kin}$ (gives the energy distribution)
\item 3-dimensional grid along $x$, $y$ and $E_\mathrm{kin}$ (gives the density map for several energies)
\item 1-dimensional grid along the charge $Z^\star$ (gives the charge distribution)
\end{itemize}
Each dimension of the grid is called ``axis".

The user may choose to average the data over several time-steps.

In the input file, you can add a particle diagnostic with the following block.
\begin{lstlisting}
DiagParticles(
	output = <>\val{output}<>,
	every = <>\val{every}<>,
	time_average = <>\val{time\_average}<>,
	species = [<>\val{species1, \blue{species2, ...}}<>],
	axes = [
		<>[\val{type, min, max, nsteps,} \blue{"logscale", "edge\_inclusive"}]<>,
		<>\blue{[\val{type, min, max, nsteps,} "logscale", "edge\_inclusive"]}<>,
		<>\blue{...}<>
	]
)
\end{lstlisting}\vspace{-10pt}

\begin{itemize}
\item \val{output} is a string: \code{"density"}, \code{"charge\_density"}, \code{"current\_density\_x"},\\
	\code{"current\_density\_y"}, \code{"current\_density\_z"}, \code{"p\_density"}, \code{"px\_density"}, \code{"py\_density"}\\
	 or \code{"pz\_density"}.\\
	It determines the data that is summed in each cell of the grid.\\
	In the case of \code{"density"}, the \textit{weights} are summed.\\
	In the case of \code{"charge\_density"}, the \textit{weights}$\times$\textit{charge} are summed.\\
	In the case of \code{"current\_density\_x"}, the \textit{weights}$\times$\textit{charge}$\times v_x$ are summed (etc.).\\
	In the case of \code{"p\_density"}, the \textit{weights}$\times p$ are summed (etc.)
\item \val{every} is a positive integer: the number of time-steps between each output.
\item \val{time\_average} is a positive integer: the number of time-steps during which the data is averaged before output.
\item \val{species1, species2, ...} is a list of strings: the names of one or several species.
	Species are recognized by their parameter \code{species\_type} that is included
	in each group \code{Species( ... )}\\
\item \code{axes} is a list of "axes".\\
	Syntax of one axis: \code{[\val{type, min, max, nsteps,} \blue{"logscale", "edge\_inclusive"}]}\\
	\val{type} is one of \code{"x"}, \code{"y"}, \code{"z"}, \code{"px"}, \code{"py"}, \code{"pz"}, \code{"p"}, 
	 \code{"gamma"}, \code{"ekin"}, \code{"vx"}, \code{"vy"}, \code{"vz"}, \code{"v"} or \code{"charge"}.\\
	The axis is discretized for \val{type} from \val{min} to \val{max} in \val{nsteps} bins.\\
	The \blue{optional} keyword \code{logscale} sets the axis scale to logarithmic instead of linear.\\
	The \blue{optional} keyword \code{edge\_inclusive} includes the particles outside the range [\val{min},  \val{max}]
	into the extrema bins.
\end{itemize}
There may be as many axes as wanted in one \code{DiagParticles( ... )} block.

There may be as many \code{DiagParticles( ... )} blocks as wanted in the input file.

In the input file, you may add the following block as a reminder.

\begin{lstlisting}
# DIAGNOSTICS ON PARTICLES - project the particles on a N-D arbitrary grid
# ------------------------------------------------------------------------
# output       = string: "density", "charge_density" or "current_density_[xyz]"
#                parameter that describes what quantity is obtained 
# every        = integer > 0: number of time-steps between each output
# time_average = integer > 0: number of time-steps to average
# species      = list of strings, one or several species whose data will be used
# axes         = list of axes
# Each axis is a list: [_type_,_min_,_max_,_nsteps_,"logscale","edge_inclusive"]
#   _type_ is a string, one of the following options:
#      x, y, z, px, py, pz, p, gamma, ekin, vx, vy, vz, v or charge
#   The data is discretized for _type_ between _min_ and _max_, in _nsteps_ bins
#   The optional "logscale" sets the scale to logarithmic
#   The optional "edge_inclusive" forces the particles that are outside (_min_,_max_)
#     to be counted in the extrema bins
#   Example : axes = [["x", 0., 1., 30]]
#   Example : axes =[["px", -1., 1., 100, "edge_inclusive"]]
\end{lstlisting}

\subsubsection*{Examples of particle diagnostics}

Variation of the density of species \code{electron1} from $x=0$ to 1, every 5 time-steps, without time-averaging.
\begin{lstlisting}
DiagParticles(
	output = "density",
	every = 5,
	time_average = 1,
	species = ["electron1"],
	axes = [ ["x",    0.,    1.,    30] ]
)
\end{lstlisting}

Density map from $x=0$ to 1, $y=0$ to 1.
\begin{lstlisting}
DiagParticles(
	output = "density",
	every = 5,
	time_average = 1,
	species = ["electron1"],
	axes = [ ["x",    0.,    1.,    30],
	         ["y",    0.,    1.,    30] ]
)
\end{lstlisting}

Velocity distribution from $v_x = -0.1$ to $0.1$.
\begin{lstlisting}
DiagParticles(
	output = "density",
	every = 5,
	time_average = 1,
	species = ["electron1"],
	axes = [ ["vx",   -0.1,    0.1,    100] ]
)
\end{lstlisting}

Phase space from $x=0$ to 1 and from $px=-1$ to 1.
\begin{lstlisting}
DiagParticles(
	output = "density",
	every = 5,
	time_average = 1,
	species = ["electron1"],
	axes = [ ["x",    0.,    1.,    30],
	         ["px",   -1.,   1.,    100] ]
)
\end{lstlisting}

Energy distribution from 0.01 to 1 MeV in logarithmic scale.
Note that the input units are $m_ec^2 \sim 0.5$ MeV.
\begin{lstlisting}
DiagParticles(
	output = "density",
	every = 5,
	time_average = 1,
	species = ["electron1"],
	axes = [ ["ekin",    0.02,    2.,   100, "logscale"] ]
)
\end{lstlisting}

$x$-$y$ density maps for three bands of energy: $[0,1]$, $[1,2]$, $[2,\infty]$.
Note the use of \code{edge\_inclusive} to reach energies up to $\infty$.
\begin{lstlisting}
DiagParticles(
	output = "density",
	every = 5,
	time_average = 1,
	species = ["electron1"],
	axes = [ ["x",    0.,    1.,    30],
	         ["y",    0.,    1.,    30],
	         ["ekin", 0.,    6.,    3,  "edge_inclusive"] ]
)
\end{lstlisting}

Charge distribution from $Z^\star =0$ to 10.
\begin{lstlisting}
DiagParticles(
	output = "density",
	every = 5,
	time_average = 1,
	species = ["electron1"],
	axes = [ ["charge",    -0.5,   10.5,   11] ]
)
\end{lstlisting}





\end{document}



